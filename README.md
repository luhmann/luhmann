I am a freelance software engineer/consultant. My main focus is Frontend Development but software is about making promises to your users and keeping them. This may start in the frontend, but you will need the whole stack to achieve that. I am happy to help skilled teams with the whole experience. I am not looking for permanent positions.

These are some of the technologies I have worked with in the past 14 years: Typescript, Javascript, CSS, HTML. React, VueJS, Angular and ecosystems. RxJs, GraphQL, Apollo, Relay. Node, Express, Serverless. Jest, Cypress, Selenium. Elm, ReasonML, ClojureScript. Kotlin, Scala, Java, Spring and ecosystems. Python, Flask, Django. PHP, Symfomy, Zend. Postgres, MySQL, Mongo. Kubernetes, Docker. AWS, Google Cloud, Azure.

I also believe that technologies do not matter much. The tools you choose should be adequate to solve the problems you encounter, but nowadays they all are. There are very few right and wrongs, almost everything is a tradeoff.

Pragmatism, Empathy and Caring are the most important values.

Unblocking your fellow programmers, product owners and project managers is the most important daily task you can do.

Complexity is the cause of all frustrations in programming. It cannot be evaded, but avoided. Most often it's a sign that things are not yet fully understood.

Maintaining software is not a lesser task than writing software, it is giving love to what makes you money right now. 

Communication is unlikely, time-consuming and can be frustrating. It is what you should try hardest to get right.

Things can be known and understood.

Knowledge needs to be pulled-in, it is almost never handed to you.

The weird edge cases you will find are not deficiencies of your tools, but expressions of human idiosyncrasy. You should embrace them. 

If you want something to change, the best way is a PR.

Having fast feedback loops is the most important thing to get right first. This means comprehensive tests, fast builds, frequent releases, a working solution for test data and testing environments, linting, static types, automatic formatting; POs, UX specialists, QA engineers and an OPs guys that are always happy to talk to you.

Do TDD when you can say exactly what you want upfront, accept the fact that you rarely can.

Document. Think READMEs instead of wikis. Keep them next to your code. Document decisions instead of implementations. Make it really easy to get started. Accept that true understanding cannot be gained from text.

The omnipresence of software means that it guides and thus limits in a very real way what people can say or do. It is your responsibility to enable them to achieve what they want. They will gladly pay you money for it. They most often will not know what they want until they see it. This should not be a cause for frustration, but iteration - preferably with solid metrics.

If you are interested in hiring me, you can contact me through my website. The link is in the sidebar. 
